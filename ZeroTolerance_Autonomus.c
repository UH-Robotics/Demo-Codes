#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    linef,          sensorLineFollower)
#pragma config(Sensor, dgtl1,  tfront,         sensorTouch)
#pragma config(Sensor, dgtl2,  tback,          sensorTouch)
#pragma config(Sensor, I2C_1,  leftIEM,        sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  rightIEM,       sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           lb1,           tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           lb2,           tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port3,           rb1,           tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port4,           rb2,           tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port5,           ls1,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           ls2,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           topflipper,    tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port8,           vfeed,         tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port9,           rs1,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          rs2,           tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(45)
#pragma userControlDuration(75)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

int a=0,speed=90;
int cupcake;
void switcheroo(void);
void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

void MoveForward(int d){				//Robot tends to steer to the left. Faster left motor speeds to compensate
	nMotorEncoder[lb1]=0;
	nMotorEncoder[rb1]=0;
	while(abs(nMotorEncoder[lb1])<d && abs(nMotorEncoder[rb1])<d){
		if((abs(nMotorEncoder[lb1])-abs(nMotorEncoder[rb1]))>20){				//Compensate if a side starts moving more than the other one
			motor[port1]=85;
			motor[port2]=-85;
			motor[port3]=-80;
			motor[port4]=80;
		}
		else if((int)(abs(nMotorEncoder[lb1])-abs(nMotorEncoder[rb1]))<-20){
			motor[port1]=105;
			motor[port2]=-105;
			motor[port3]=-80;
			motor[port4]=80;
		}
		else{
			motor[port1]=95;
			motor[port2]=-95;
			motor[port3]=-80;
			motor[port4]=80;
		}
	}
			motor[port3]=50;					//Correct residual right wheels spin
			motor[port4]=-50;
			wait10Msec(1);
}

void TurnRight(int r){					//r=600 is about a 360 degree turn
	nMotorEncoder[lb1]=0;
	nMotorEncoder[rb1]=0;
	while(abs(nMotorEncoder[lb1])<r && abs(nMotorEncoder[rb1])<r){
		if((abs(nMotorEncoder[lb1])-abs(nMotorEncoder[rb1]))>20){
			motor[port1]=900;
			motor[port2]=-90;
			motor[port3]=90;
			motor[port4]=-90;
		}
		else if((int)(abs(nMotorEncoder[lb1])-abs(nMotorEncoder[rb1]))<-20){
			motor[port1]=110;
			motor[port2]=-110;
			motor[port3]=90;
			motor[port4]=-90;
		}
		else{
			motor[port1]=100;
			motor[port2]=-100;
			motor[port3]=90;
			motor[port4]=-90;
		}
	}
}

void TurnLeft(int r){						//r=600 is about a 360 degree turn
	nMotorEncoder[lb1]=0;
	nMotorEncoder[rb1]=0;
	while(abs(nMotorEncoder[lb1])<r && abs(nMotorEncoder[rb1])<r){
		if((abs(nMotorEncoder[lb1])-abs(nMotorEncoder[rb1]))>20){
			motor[port1]=-90;
			motor[port2]=90;
			motor[port3]=-90;
			motor[port4]=90;
		}
		else if((int)(abs(nMotorEncoder[lb1])-abs(nMotorEncoder[rb1]))<-20){
			motor[port1]=-110;
			motor[port2]=110;
			motor[port3]=-90;
			motor[port4]=90;
		}
		else{
			motor[port1]=-100;
			motor[port2]=100;
			motor[port3]=-90;
			motor[port4]=90;
		}
	}
}

void UntilLine(){
	nMotorEncoder[lb1]=0;
	nMotorEncoder[rb1]=0;
	while(SensorValue[in1]>180){
		if((abs(nMotorEncoder[lb1])-abs(nMotorEncoder[rb1]))>25){
			motor[port1]=-100;
			motor[port2]=-100;
			motor[port3]=-90;
			motor[port4]=90;
		}
		else if((int)(abs(nMotorEncoder[lb1])-abs(nMotorEncoder[rb1]))<-25){
			motor[port1]=-120;
			motor[port2]=-120;
			motor[port3]=-90;
			motor[port4]=90;
		}
		else{
			motor[port1]=-110;
			motor[port2]=-110;
			motor[port3]=-90;
			motor[port4]=90;
		}
	}
}

void Stahp(void){
	motor[port1]=0;
	motor[port2]=0;
	motor[port3]=0;
	motor[port4]=0;
}

void ShootBall(){
	while(SensorValue[dgtl1]==0){
		motor[port7]=100;
	}
	while(SensorValue[dgtl2]==0){
	motor[port7]=-50;
	}
	motor[port7]=0;
}

void ShootBalls(){
		motor[port5]=speed;						//This code makes the robot shoot 3 balls. AND IT WORKS
    motor[port6]=speed;
    motor[port9]=-speed;
    motor[port10]=-speed;
    wait10Msec(150);
    for(a=0;a<3;a++){
    	ShootBall();
    	motor[port8]=127;
    	wait10Msec(300);
    	motor[port8]=0;
    }
    	motor[port5]=0;
    	motor[port6]=0;
    	motor[port9]=0;
    	motor[port10]=0;
}

task autonomous()
{
		MoveForward(1600);
		Stahp();
		wait10Msec(50);
		TurnRight(150);								//90 degree right turn
		Stahp();
		wait10Msec(50);
    MoveForward(200);
    Stahp();
    wait10Msec(50);
    TurnLeft(180);								//90 degree left turn
		Stahp();
		wait10Msec(50);
		ShootBalls();
    TurnRight(250);								//180 degree turn
    Stahp();
    wait10Msec(50);
    motor[port8]=127;
    MoveForward(1200);
    Stahp();
    motor[port8]=0;
    wait10Msec(50);
    TurnRight(200);								//180 degree turn
    Stahp();
    wait10Msec(50);
    MoveForward(1200);
    Stahp();
    wait10Msec(50);
    ShootBalls();
}

task usercontrol()
{
	// User control code here, inside the loop

	while (true)
	{
	  motor[port3]=-vexRT[Ch2];
		motor[port4]=vexRT[Ch2];
		motor[port1]=vexRT[Ch3];
		motor[port2]=-vexRT[Ch3];

	if(vexRT[Btn6U]==1)
    {
    	motor[port5]=speed;
    	motor[port6]=speed;
    	motor[port9]=-speed;
    	motor[port10]=-speed;
    }
    else
    {
    	motor[port5] = 0;
    	motor[port6] = 0;
    	motor[port9] = 0;
    	motor[port10] = 0;
    }
   if(vexRT[Btn5U]==1)
    {
   		motor[port8]= 127;
    }
   else if(vexRT[Btn5D]==1)
    {
     motor[port8]= -127;
    }
   else
    {
     motor[port8]= 0;
    }

    if(vexRT[Btn7L]==1){switcheroo();}

   if(cupcake==1 && SensorValue[dgtl1]==0){motor[port7]=100;}
   else if(cupcake==2 && SensorValue[dgtl2]==0){motor[port7]=-50;}
   else{motor[port7]=0;}

   if(SensorValue[dgtl1]==1){cupcake=2;}
   if(SensorValue[dgtl2]==1){cupcake=0;}

   /*  Manual Ball flipper Code
   if(vexRT[Btn7L]==1 && SensorValue[dgtl1]==0)
    {
     motor[port7]=100;
    }
   else if(vexRT[Btn7R]==1 && SensorValue[dgtl2]==0)
    {
     motor[port7]=-100;
    }
   else
    {
     motor[port7]=0;
    }*/
	}
}

void switcheroo(void){cupcake=1;}
